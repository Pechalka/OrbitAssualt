<html>
<head>
	<title>Orbit Assualt (a DHTML arcade game)</title>
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
	<style type="text/css">
#draw-target{
	width: 480px;
	height: 384px;
	background-color: #000;
	position: relative;
	color: #FFF;
	font-size: 16px;
	font-family: "Courier New", Courier, monospace;
	font-weight: bold;
	letter-spacing: 1px;
}

.message {
	margin-left: auto;
	margin-right: auto;
	padding-top: 32px;
	text-align: center;
}

#score {
	position: absolute;
	top: 8px;
	left: 16px;
}

#highScore {
	position: absolute;
	top: 8px;
	right: 16px;
}

#lives {
	margin-left: auto;
	margin-right: auto;
	padding-top: 8px;
	text-align: center;
}


	</style>
	<script type="text/javascript">





	$(function() {


try { //hack for IE
    document.execCommand("BackgroundImageCache", false, true);
} catch(err) {};



var PLAYER = 1,
    LASER = 2,
    ALIEN = 4,
    ALIEN_BOMB = 8,
    SHIELD = 16,
    SAUCER = 32,
    TOP_OF_SCREEN = 64,

	TANK_Y = 352 - 16,
	SCREEN_WIDTH = 480,
    SYS_timeInfo,
    SYS_collisionManager,
	SYS_process,
	SYS_spriteParams = {
        width: 32,
        height: 32,
        imagesWidth: 256,
        images: 'invaders.png',
        $drawTarget: $('#draw-target')
    };


// process
var processor = function () {
    var processList = [],
        addedItems = [];
    return {
        add: function (process) {
            addedItems.push(process);
        },
        process: function () {
            var newProcessList = [],
            len = processList.length;
            for (var i = 0; i < len; i++) {
                if (!processList[i].removed) {
                    processList[i].move();
                    newProcessList.push(processList[i]);
                }
            }
            processList = newProcessList.concat(addedItems);
            addedItems = [];
        }
    };
};


// collision manager
var collisionManager = function () {
    var listIndex = 0,
        checkListIndex = 0,
        grid = [],
        checkList = {},
        gridWidth = 15,
        gridHeight = 12;

    for (var i = 0; i < gridWidth * gridHeight; i++) {
        grid.push({});
    }

    var getGridList = function (x, y) {
        var idx = (Math.floor(y / 32) * gridWidth) + Math.floor(x / 32);
        if (grid[idx] === undefined) {
            return;
        }
        return grid[idx];
    };
    return {
        newCollider: function (colliderFlag, collideeFlags, width, height, callback) {
            var list, indexStr = '' + listIndex++,
                checkIndex;
            var colliderObj = {
                halfWidth: width / 2,
                halfHeight: height / 2,
                centerX: 0,
                centerY: 0,
                colliderFlag: colliderFlag,
                collideeFlags: collideeFlags,
                update: function (x, y) {
                    colliderObj.centerX = x + 16;
                    colliderObj.centerY = y + 32 - colliderObj.halfHeight;
                    if (list) {
                        delete list[indexStr];
                    }
                    list = getGridList(colliderObj.centerX, colliderObj.centerY);
                    if (list) {
                        list[indexStr] = colliderObj;
                    }
                },
                remove: function () {
                    if (collideeFlags) {
                        delete checkList[checkIndex];
                    }
                    if (list) { // list could be undefined if item was off-screen
                        delete list[indexStr];
                    }
                },
                callback: function () {
                    callback();
                },
                checkCollisions: function (offsetX, offsetY) {
                    
                    var list = getGridList(colliderObj.centerX + offsetX,
                                           colliderObj.centerY + offsetY);
                    if (!list) {
                        return;
                    }
                    var idx, collideeObj;
                    for (idx in list) {
                        if (list.hasOwnProperty(idx) &&
                            idx !== indexStr &&
                            (colliderObj.collideeFlags & list[idx].colliderFlag)) {

                            collideeObj = list[idx];
                            if (Math.abs(colliderObj.centerX - collideeObj.centerX) >
                                (colliderObj.halfWidth + collideeObj.halfWidth)) {
                                continue;
                            }
                            if (Math.abs(colliderObj.centerY - collideeObj.centerY) >
                                (colliderObj.halfHeight + collideeObj.halfHeight)) {
                                continue;
                            }
                            collideeObj.callback(colliderObj.colliderFlag);
                            callback(collideeObj.colliderFlag);
                            return true;
                        }
                    }
                    return false;
                }
            };
            if (collideeFlags) {
                checkIndex = '' + checkListIndex++;
                checkList[checkIndex] = colliderObj;

            }
            return colliderObj;
        },
        checkCollisions: function () {
            var idx, colliderObj;
            for (idx in checkList) {
                if (checkList.hasOwnProperty(idx)) {
                    colliderObj = checkList[idx];

                    for (var y = -32; y <= 32; y += 32) {
                        for (var x = -32; x <= 32; x += 32) {
                            if (colliderObj.checkCollisions(x, y)) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    };
};


var DHTMLSprite = function (params) {
		 var width = params.width,
				 height = params.height,
				 imagesWidth = params.imagesWidth,
				 $element = params.$drawTarget.append('<div/>').find(':last'),
				 elemStyle = $element[0].style,
				 mathFloor = Math.floor;
		 $element.css({
				 position: 'absolute', left:-9999,/*********************/
				 width: width,
				 height: height,
				 backgroundImage: 'url(' + params.images + ')'
		 });
		 var that = {
				 draw: function (x, y) {
						 elemStyle.left = x + 'px';
						 elemStyle.top = y + 'px';
				 },
				 changeImage: function (index) {
						 index *= width;
						 var vOffset = -mathFloor(index / imagesWidth) * height;
						 var hOffset = -index % imagesWidth;
						 elemStyle.backgroundPosition = hOffset + 'px ' + vOffset + 'px';
				 },
				 show: function () {
						 elemStyle.display = 'block';
				 },
				 hide: function () {
						 elemStyle.display = 'none';
				 },
				 destroy: function () {
						 $element.remove();
				 }
		 };
		 return that;
};

var timeInfo = function (goalFPS) {
    var oldTime, paused = true,
        iterCount = 0,
        totalFPS = 0,
        totalCoeff = 0;
    return {
        getInfo: function () {

            if (paused === true) {
                paused = false;
                oldTime = +new Date();
                return {
                    elapsed: 0,
                    coeff: 0,
                    FPS: 0,
                    averageFPS: 0
                };
            }

            var newTime = +new Date();
            var elapsed = newTime - oldTime;
            oldTime = newTime;
            var FPS = 1000 / elapsed;
            iterCount++;
            totalFPS += FPS;

            var coeff = goalFPS / FPS;
            totalCoeff += coeff;


            return {
                elapsed: elapsed,
                coeff: 1,// coeff,
                FPS: FPS,
                averageFPS: totalFPS / iterCount,
                averageCoeff: totalCoeff / iterCount
            };
        },
        pause: function () {
            paused = true;
        }
    };
};

// Animation effect.
var animEffect = function (x, y, imageList, timeout) {
    var imageIndex = 0,
        that = DHTMLSprite(SYS_spriteParams);
        setTimeout(function(){
            that.removed = true;
            that.destroy();
        }, timeout);
    that.move = function () {
        that.changeImage(imageList[imageIndex]);
        imageIndex++;
        if (imageIndex === imageList.length) {
            imageIndex = 0;
        }
        that.draw(x, y);
    };
    SYS_process.add(that);
};


// Key input.
var keys = function () {
    var keyMap = {
        '90': 'left',
        '88': 'right',
        '77': 'fire'
    },
        kInfo = {
            'left': 0,
            'right': 0,
            'fire': 0
        },
        key;
    $(document).bind('keydown keyup', function (event) {
        key = '' + event.which;
        if (keyMap[key] !== undefined) {
            kInfo[keyMap[key]] = event.type === 'keydown' ? 1 : 0;
            return false;
        }
    });
    return kInfo;
}();



// Saucer.
var saucer = function (gameCallback) {
    var dx = (Math.floor(Math.random() * 2) * 2) - 1,
        x = 0;
    dx *= 1.25;
    if (dx < 0) {
        x = SCREEN_WIDTH - 32;
    }

    var that = DHTMLSprite(SYS_spriteParams);
    that.changeImage(20);

    var remove = function () {
        that.destroy();
        collider.remove();
        that.removed = true;
    };

    var hit = function () {
        remove();
        gameCallback({
            message: 'saucerHit',
            x: x,
            y: 32
        });
    };

    var collider = SYS_collisionManager.newCollider(SAUCER, 0, 32, 14, hit);

    that.move = function () {

        that.draw(x, 32);
        collider.update(x, 32);
        x += dx;
        if (x < 0 || x > SCREEN_WIDTH - 32) {
            remove();
        }
    };

    SYS_process.add(that);
}

// Player bomb.
var laser = function (x, y, callback) {
    var that = DHTMLSprite(SYS_spriteParams);
    that.remove = function (collideeFlags) {
        if (collideeFlags & (TOP_OF_SCREEN + SHIELD + ALIEN_BOMB)) {
            animEffect(x, y, [18], 250);
        }
        that.destroy();
        collider.remove();
        that.removed = true;
        setTimeout(callback, 200);
    };

    var collider = SYS_collisionManager.newCollider(LASER, ALIEN + ALIEN_BOMB + SHIELD + SAUCER, 2, 10, that.remove);
    that.changeImage(7);
    that.move = function () {
        y -= 7 * SYS_timeInfo.coeff;
        that.draw(x, y);
        collider.update(x, y);
        if (y <= -8) {
            that.remove(TOP_OF_SCREEN);
        }
    };
	SYS_process.add(that);
};



// tank
var tank = function (gameCallback) {
    var x = ((SCREEN_WIDTH / 2) - 160),
	    canFire = true,
        collider,
        waitFireRelease = true,
        that = DHTMLSprite(SYS_spriteParams);
    that.changeImage(6);
    that.draw(x, TANK_Y);
    that.canFire = function () {
        canFire = true;
    };
    that.move = function () {
        var dx = keys.left ? -2 : 0;
        dx = keys.right ? 2 : dx;

        x += dx * SYS_timeInfo.coeff;
        if (dx > 0 && x >= (SCREEN_WIDTH / 2) + 168) {
            x = (SCREEN_WIDTH / 2) + 168;
        }
        if (dx < 0 && x <= (SCREEN_WIDTH / 2) - 200) {
            x = (SCREEN_WIDTH / 2) - 200;
        }

        that.draw(x, TANK_Y);
  //      collider.update(x, TANK_Y);
        if (canFire) {
            if (keys.fire) {
                if (!waitFireRelease) {
                    laser(x, TANK_Y+8, function(){canFire = true;});
                    canFire = false;
                    waitFireRelease = true;
                }
            } else {
                waitFireRelease = false;
            }
        }
    };
    that.hit = function () {
      //  collider.remove();
        that.destroy();  //hidden = true;
        that.removed = true;
   //     animEffect(x, TANK_Y, [8], 250);
        gameCallback({
            message: 'playerKilled'
        });
    };

//    collider = SYS_collisionManager.newCollider(PLAYER, ALIEN_BOMB, 30, 12, that.hit);
    SYS_process.add(that);
};


var game = function(){
	var time,
		lives,
		score = 0,
		extraLifeScore = 0,
		highScore = 0,
		saucerTimeout = 0,
		gameOverFlag = false,
		gameState = 'titleScreen',
		startText =
            '<div class="message">' +
            '<p>ORBIT ASSAULT</p>' +
            '<p>Press FIRE to Start</p>' +
            '<p>Z = LEFT</p>' +
            '<p>X = RIGHT</p>' +
            '<p>M - FIRE</p>' +
            '<p>EXTRA TANK EVERY 5000 POINTS</p>' +
            '</div>',
    newSaucer = function(){

    	clearTimeout(saucerTimeout);
    	saucerTimeout = setTimeout(function(){
    		
    		saucer(gameCallback);
    		newSaucer();
    	}, (Math.random() * 5000) + 15000);
    },        
    gameCallback = function(){

    },
    
    init = function(){
    	 $("#draw-target").children().remove();
            SYS_process = processor();
            lives = 3;
            SYS_collisionManager = collisionManager();
           // aliens = aliensManager(gameCallback, aliensStartY);
           setTimeout(function () {
               tank(gameCallback);
           }, 2000);
           // initShields();
            newSaucer();
            updateScores();
    },
    updateScores  = function(){
		if (score - extraLifeScore >= 5000 ){
			extraLifeScore += 5000;
			lives++;
		}
		if (!$('#score').length){
			$("#draw-target").append(
				'<div id="score"></div>' + 
				'<div id="lives"></div><div id="highScore"></div>');
		}
		if (score > highScore){
			highScore = score;
		}

		$('#score').text('SCORE: ' + score);
		$('#lives').text('LIVES: ' + lives );
		$('#highScore').text('HIGH: ' + highScore);
	},
	gameLoop = function () {
            switch (gameState) {
            case 'playing':

                SYS_timeInfo = time.getInfo();
                SYS_process.process();
                SYS_collisionManager.checkCollisions();
                break;

            case 'titleScreen':
                if (keys.fire) {
                    gameOverFlag = false;
                    time = timeInfo(60);
                    keys.fire = 0;
                    lives = 3;
                    score = 0;
                    extraLifeScore = 0;
                  //  aliensStartY = 64;
                    gameState = 'playing';
                    init();
                }
            }
            setTimeout(gameLoop, 15);
        };
	

	$("#draw-target").append(startText);	


	gameLoop();
}();

	});
	</script>
</head>
<body>
	<div id="draw-target"></div>
</body>
</html>